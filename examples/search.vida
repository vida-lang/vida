//
// search.vida
// Implementation of classic search algorithms like DFS and BFS
// Based on Harvard CS50 python implementation.
//


let io = import("io")
let fmt = import("fmt")


// Node is the struct for modeling a node in the search graph.
struct Node {
    pub state parent action
    fun new state parent action {
        return Node(state:state, parent:parent, action:action)
    }
}


// StackFrontier models a stack of nodes.
struct StackFrontier {
    pub frontier
    
    // Creates a new StackFrontier.
    fun new {
        return StackFrontier(frontier:[])
    }
    
    // Adds a node to the stack.
    fun add self node {
        self.frontier.append(node)
    }
    
    // Checks whether a node has the given state.
    fun containsState self state {
        for node in self.frontier {
            if node.state == state {
                return true
            }
        }
        return false
    }
    
    // Tells if the stack is empty.
    fun isEmpty self {
        return self.frontier.isEmpty()
    }
    
    // Pops a value from the stack. Returns a Result type.
    fun remove self {
        if self.isEmpty() {
            return Error("Empty frontier")
        }
        return Ok(self.frontier.popLast())
    }
}


// QueueFrontier models a queue of nodes. Derives functionality from StackFrontier.
struct QueueFrontier < StackFrontier {
    // Creates a new QueueFrontier.
    fun new {
        return QueueFrontier(frontier:[])
    }
    
    // Removes a node from the queue. Returns a Result type.
    fun remove self {
        if self.isEmpty() {
            return Error("Empty frontier")
        }
        return Ok(self.frontier.popFirst())
    }
}


// Maze models the data structure conataining the search problem to solve.
struct Maze {
    pub height width walls start goal solution
    
    // Creates a new Maze from a file.
    fun new filename {
        let file, err = io.openFile(filename, io.r)
        if err {
            panic(err)
        }
        defer file.close()
        let maze = Maze()
        let buffer = Bytes(file.info().size)
        file.readAt(buffer, 0)
        let contents = String(buffer)
        assert(contents.count("A") == 1, "maze must have exactly one start point")
        assert(contents.count("B") == 1, "maze must have exactly one goal")
        contents = contents.split("\n")
        contents.popLast()
        maze.height = contents.length()
        assert(maze.height > 0, "maze must have at least one row")
        maze.width = contents[0].length()
        for item in contents {
            assert(item.length() == maze.width, "maze must have NxM dimension")
        }
        maze.walls = []
        for i in range maze.height {
            let row = []
            for j in range maze.width {
                switch contents[i][j] {
                    case 'A':
                        maze.start = [i, j]
                        row.append(false)
                    case 'B':
                        maze.goal = [i, j]
                        row.append(false)
                    case ' ':
                        row.append(false)
                    default:
                        row.append(true)
                }
            }
            maze.walls.append(row)
        }
        return maze
    }
    
    fun print self {
        let solution = nil
        if self.solution {
            solution = self.solution[1]
        }
        print()
        for i, row in range self.walls {
            for j, col in range row {
                if col {
                    fmt.printf("â–ˆ")
                } else if [i, j] == self.start {
                    fmt.printf("A")
                } else if [i, j] == self.goal {
                    fmt.printf("B")
                } else if solution != nil {
                    if solution.contains([i, j]) {
                        fmt.printf("*")
                    }
                } else {
                    fmt.printf(" ")
                }
            }
            print()
        }
        print()
    }
    
    fun neighbors self state {
        let row, col = state
        let candidates = [
            ["up", row - 1, col],
            ["down", row + 1, col],
            ["left", row, col - 1],
            ["right", row, col + 1]
        ]
        let result = []
        for action, r, c in candidates {
            if 0 <= r and r < self.height and 0 <= c and c < self.width and not self.walls[r][c] {
                result.append([action, r, c])
            }
        }
        return result
    }
    
    fun solve self {
        self.numExplored = 0
        let start = Node.new(self.start, nil, nil)
        let frontier = StackFrontier.new()
        frontier.add(start)
        self.explored = Set()
        for {
            if frontier.isEmpty() {
                return Error("No solution found")
            }
            let node = frontier.remove()
            self.numExplored += 1
            if node.state == self.goal {
                let actions, cells = [], []
                for node.parent {
                    actions.append(node.action)
                    cells.append(node.state)
                    node = node.parent
                }
                actions.reverse()
                cells.reverse()
                self.solution = [actions, cells]
                return nil
            }
        }
    }
}


fun run {
    let args = argv()
    if args.length() != 2 {
        print("Usage: vida search.vida maze.txt")
        exit()
    }
    let maze = Maze.new(args[1])
    print("Maze:")
    maze.print()
}


run()




